#include <encryption/encryption.hpp>
#include <modes.h>
#include <rijndael.h>

namespace Magnus::LibMagnus
{
Encryption::Encryption()
{
	mKeys.dh_key.GenerateKeyPair(mRng, mKeys.private_key, mKeys.public_key);
}

Encryption::~Encryption()
{
}

Keys &Encryption::get_keys()
{
	return mKeys;
}

// param pKeys: person B's Keys.
// variable mKeys: person A's keys
SecByteBlock Encryption::generate_shared_key(Keys &pKeys)
{
	// pKeys = Keys that were provided
	// mKeyss = Keys that were generated in the class

	if (pKeys.public_key.empty())
		throw std::runtime_error("Please provide a public key");

	// Check if both keys have equal lengths
	if (mKeys.dh_key.AgreedValueLength() != mKeys.dh_key.AgreedValueLength())
		throw std::runtime_error("Shared shared size mismatch");

	// Shared key
	mSharedKey = SecByteBlock(mKeys.dh_key.AgreedValueLength());

	// Generate shared secret withe locally stored private key
	// and the newly obtaind public key

	if (!mKeys.dh_key.Agree(mSharedKey, mKeys.private_key, pKeys.public_key))
		throw std::runtime_error("Failed to reach shared secret");

	return mSharedKey;
}

Integer Encryption::decode_shared_key(SecByteBlock &shared_key)
{
	Integer shared_secret;
	shared_secret.Decode(shared_key.BytePtr(), shared_key.SizeInBytes());

	return shared_secret;
}

void Encryption::encrypt_data_aes_256(SecByteBlock &key, std::string &data, byte *out_data,
									  const CryptoPP::byte *iv)
{
	if (key.size() != AES::MAX_KEYLENGTH)
	{
		throw std::runtime_error("Encryption Key and AES Key lengths don't match.");
	}

	if (AES::BLOCKSIZE != 16)
	{
		throw std::runtime_error("The block size is NOT 16.");
	}

	// encrypt with the shared key generated by A

	byte data_bytes[data.size()];
	Magnus::LibMagnus::string_to_byte(data, data_bytes);

	CFB_Mode<AES>::Encryption encryptor(key, AES::MAX_KEYLENGTH, iv);
	encryptor.ProcessData(data_bytes, data_bytes, data.size());
	std::memcpy(out_data, data_bytes, data.size());
}

void Encryption::decrypt_data_aes_256(SecByteBlock &key, std::string &data, byte *out_data,
									  const CryptoPP::byte *iv)
{
	if (key.size() != AES::MAX_KEYLENGTH)
	{
		throw std::runtime_error("Encryption Key and AES Key lengths don't match.");
	}

	if (AES::BLOCKSIZE != 16)
	{
		throw std::runtime_error("The block size is NOT 16.");
	}

	byte data_bytes[data.size()];
	Magnus::LibMagnus::string_to_byte(data, data_bytes);

	// encrypt with the shared key generated by A
	CFB_Mode<AES>::Decryption decryptor(key, key.size(), iv);
	decryptor.ProcessData(data_bytes, data_bytes, data.size());
	std::memcpy(out_data, data_bytes, data.size());
}

void Encryption::decrypt_data_aes_256(SecByteBlock &key, byte *data, size_t length, byte *out_data,
									  const CryptoPP::byte *iv)
{
	if (key.size() != AES::MAX_KEYLENGTH)
	{
		throw std::runtime_error("Encryption Key and AES Key lengths don't match.");
	}

	if (AES::BLOCKSIZE != 16)
	{
		throw std::runtime_error("The block size is NOT 16.");
	}

	// encrypt with the shared key generated by A
	CFB_Mode<AES>::Decryption decryptor(key, key.size(), iv);
	decryptor.ProcessData(data, data, length);
	std::memcpy(out_data, data, length);
}

void string_to_byte(std::string &data, byte *data_bytes)
{
	std::copy(data.begin(), data.end(), data_bytes);
	data_bytes[data.length()] = 0;
}
}; // namespace Magnus::LibMagnus
